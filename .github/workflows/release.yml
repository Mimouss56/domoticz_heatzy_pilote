name: Release Management

on:
  push:
    branches: [ main, master ]
    paths-ignore:
      - 'README*.md'
      - 'CHANGELOG.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      pre_release:
        description: 'Create pre-release'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: "3.8"

jobs:
  check-version:
    name: Check Version Bump
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      new_version: ${{ steps.version.outputs.new_version }}
      version_type: ${{ steps.check.outputs.version_type }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install semver
      run: |
        pip install semver gitpython
        
    - name: Check for version bump need
      id: check
      run: |
        python3 << 'EOF'
        import os
        import re
        import git
        import semver
        from datetime import datetime
        
        # Get current version from plugin
        with open('plugin_modular.py', 'r') as f:
            content = f.read()
            version_match = re.search(r'version="([^"]+)"', content)
            if version_match:
                current_version = version_match.group(1)
            else:
                current_version = "0.0.1"
        
        print(f"Current version: {current_version}")
        
        # Check if we need to bump version
        repo = git.Repo('.')
        
        # Get commits since last tag
        try:
            last_tag = repo.git.describe('--tags', '--abbrev=0')
            commits_since_tag = list(repo.iter_commits(f'{last_tag}..HEAD'))
        except:
            commits_since_tag = list(repo.iter_commits('HEAD'))
            last_tag = None
        
        print(f"Commits since last tag: {len(commits_since_tag)}")
        
        # Analyze commit messages for version bump type
        version_bump = "patch"
        should_release = False
        
        if len(commits_since_tag) > 0:
            should_release = True
            
            for commit in commits_since_tag:
                message = commit.message.lower()
                if any(keyword in message for keyword in ['break', 'breaking', 'major']):
                    version_bump = "major"
                elif any(keyword in message for keyword in ['feat', 'feature', 'minor']):
                    if version_bump != "major":
                        version_bump = "minor"
        
        # Override with manual input if provided
        manual_type = "${{ github.event.inputs.version_type }}"
        if manual_type:
            version_bump = manual_type
            should_release = True
        
        print(f"Version bump type: {version_bump}")
        print(f"Should release: {should_release}")
        
        # Set outputs
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"should_release={str(should_release).lower()}\n")
            f.write(f"version_type={version_bump}\n")
        EOF
        
    - name: Calculate new version
      id: version
      if: steps.check.outputs.should_release == 'true'
      run: |
        python3 << 'EOF'
        import os
        import re
        import semver
        
        # Get current version
        with open('plugin_modular.py', 'r') as f:
            content = f.read()
            version_match = re.search(r'version="([^"]+)"', content)
            if version_match:
                current_version = version_match.group(1)
            else:
                current_version = "0.0.1"
        
        # Parse version
        try:
            version_info = semver.VersionInfo.parse(current_version)
        except:
            version_info = semver.VersionInfo.parse("1.0.0")
        
        # Bump version
        version_type = "${{ steps.check.outputs.version_type }}"
        if version_type == "major":
            new_version = str(version_info.bump_major())
        elif version_type == "minor":
            new_version = str(version_info.bump_minor())
        else:
            new_version = str(version_info.bump_patch())
        
        print(f"New version: {new_version}")
        
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"new_version={new_version}\n")
        EOF

  update-version:
    name: Update Version
    runs-on: ubuntu-latest
    needs: check-version
    if: needs.check-version.outputs.should_release == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Update version in files
      run: |
        NEW_VERSION="${{ needs.check-version.outputs.new_version }}"
        
        # Update plugin_modular.py
        sed -i "s/version=\"[^\"]*\"/version=\"$NEW_VERSION\"/" plugin_modular.py
        
        # Update __init__.py
        sed -i "s/__version__ = \"[^\"]*\"/__version__ = \"$NEW_VERSION\"/" src/__init__.py
        
        # Update CHANGELOG.md
        python3 << EOF
        import re
        from datetime import datetime
        
        version = "$NEW_VERSION"
        today = datetime.now().strftime("%Y-%m-%d")
        
        # Read current changelog
        with open('CHANGELOG.md', 'r') as f:
            content = f.read()
        
        # Find the unreleased section or create one
        unreleased_pattern = r'## \[Unreleased\].*?(?=\n## \[|\nEOF)'
        
        if '## [Unreleased]' in content:
            # Replace unreleased with new version
            new_section = f"## [{version}] - {today}"
            content = re.sub(r'## \[Unreleased\]', new_section, content)
        else:
            # Add new version section after first heading
            first_heading = content.find('\n## ')
            if first_heading != -1:
                new_section = f"\n## [{version}] - {today}\n\n### Changed\n- Automated release\n"
                content = content[:first_heading] + new_section + content[first_heading:]
        
        # Write updated changelog
        with open('CHANGELOG.md', 'w') as f:
            f.write(content)
        EOF
        
        echo "Updated version to $NEW_VERSION"
        
    - name: Commit version changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "chore: bump version to ${{ needs.check-version.outputs.new_version }}"
        git push

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [check-version, update-version]
    if: needs.check-version.outputs.should_release == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Create release package
      run: |
        VERSION="${{ needs.check-version.outputs.new_version }}"
        PACKAGE_NAME="heatzy_pilote_v${VERSION}"
        
        # Create package directory
        mkdir -p "dist/${PACKAGE_NAME}"
        
        # Copy plugin files
        cp plugin_modular.py "dist/${PACKAGE_NAME}/plugin.py"
        cp -r src/ "dist/${PACKAGE_NAME}/"
        
        # Copy documentation
        cp README.md "dist/${PACKAGE_NAME}/"
        cp README_FR.md "dist/${PACKAGE_NAME}/"
        cp CHANGELOG.md "dist/${PACKAGE_NAME}/"
        cp ARCHITECTURE.md "dist/${PACKAGE_NAME}/"
        
        # Create install script
        cat > "dist/${PACKAGE_NAME}/install.sh" << 'INSTALL_EOF'
        #!/bin/bash
        # Heatzy Pilote Plugin Installer
        
        DOMOTICZ_DIR="/opt/domoticz"
        PLUGIN_DIR="$DOMOTICZ_DIR/plugins/heatzy_pilote"
        
        echo "Installing Heatzy Pilote Plugin..."
        
        # Check if Domoticz directory exists
        if [ ! -d "$DOMOTICZ_DIR" ]; then
            echo "Error: Domoticz directory not found at $DOMOTICZ_DIR"
            exit 1
        fi
        
        # Create plugin directory
        sudo mkdir -p "$PLUGIN_DIR"
        
        # Copy files
        sudo cp plugin.py "$PLUGIN_DIR/"
        sudo cp -r src/ "$PLUGIN_DIR/"
        sudo cp *.md "$PLUGIN_DIR/"
        
        # Set permissions
        sudo chown -R domoticz:domoticz "$PLUGIN_DIR"
        sudo chmod +x "$PLUGIN_DIR/plugin.py"
        
        echo "Plugin installed successfully!"
        echo "Please restart Domoticz to load the plugin."
        INSTALL_EOF
        
        chmod +x "dist/${PACKAGE_NAME}/install.sh"
        
        # Create archives
        cd dist
        tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}/"
        zip -r "${PACKAGE_NAME}.zip" "${PACKAGE_NAME}/"
        
        # Create checksums
        sha256sum "${PACKAGE_NAME}.tar.gz" > "${PACKAGE_NAME}.tar.gz.sha256"
        sha256sum "${PACKAGE_NAME}.zip" > "${PACKAGE_NAME}.zip.sha256"
        
    - name: Generate release notes
      run: |
        VERSION="${{ needs.check-version.outputs.new_version }}"
        
        python3 << 'EOF'
        import re
        
        version = "${{ needs.check-version.outputs.new_version }}"
        
        # Extract release notes from CHANGELOG
        with open('CHANGELOG.md', 'r') as f:
            content = f.read()
        
        # Find this version's section
        pattern = rf'## \[{re.escape(version)}\].*?(?=\n## \[|\nEOF)'
        match = re.search(pattern, content, re.DOTALL)
        
        if match:
            release_notes = match.group(0)
            # Clean up the section
            release_notes = re.sub(rf'## \[{re.escape(version)}\][^\n]*\n', '', release_notes)
        else:
            release_notes = f"Release {version}"
        
        # Add download instructions
        release_notes += f"""
        
        ## 📦 Installation
        
        ### Quick Install
        ```bash
        wget https://github.com/Mimouss56/domoticz_heatzy_pilote/releases/download/v{version}/heatzy_pilote_v{version}.tar.gz
        tar -xzf heatzy_pilote_v{version}.tar.gz
        cd heatzy_pilote_v{version}
        sudo ./install.sh
        ```
        
        ### Manual Install
        1. Download `heatzy_pilote_v{version}.zip`
        2. Extract to your Domoticz plugins directory
        3. Rename `plugin_modular.py` to `plugin.py`
        4. Restart Domoticz
        
        ## 🔧 Verification
        ```bash
        # Test the plugin
        python3 test_modular.py
        ```
        """
        
        with open('release_notes.md', 'w') as f:
            f.write(release_notes)
        EOF
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.check-version.outputs.new_version }}
        name: Release v${{ needs.check-version.outputs.new_version }}
        body_path: release_notes.md
        draft: false
        prerelease: ${{ github.event.inputs.pre_release == 'true' }}
        files: |
          dist/*.tar.gz
          dist/*.zip
          dist/*.sha256
        token: ${{ secrets.GITHUB_TOKEN }}

  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [check-version, create-release]
    if: needs.check-version.outputs.should_release == 'true'
    
    steps:
    - name: Send release notification
      run: |
        echo "🎉 Released version ${{ needs.check-version.outputs.new_version }}"
        echo "📦 Download: https://github.com/Mimouss56/domoticz_heatzy_pilote/releases/tag/v${{ needs.check-version.outputs.new_version }}"